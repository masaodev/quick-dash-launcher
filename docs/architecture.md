# アーキテクチャ詳細

## プロセス構造
- **メインプロセス** (`src/main/main.ts`): システム操作、ウィンドウ管理、IPCを処理するElectronメインプロセス
- **レンダラープロセス** (`src/renderer/`): UIのためのReactアプリケーション
- **プリロードスクリプト** (`src/main/preload.ts`): レンダラーに限定的なAPIを公開するセキュアブリッジ
- **共通型定義** (`src/common/types.ts`): プロセス間で共有される型定義

## IPCハンドラー構造
IPCハンドラーは機能ごとに分離（`src/main/ipc/`）:
- `configHandlers.ts`: 設定フォルダーへのアクセス
- `dataHandlers.ts`: データファイルの読み込み・保存、アイテム登録
- `itemHandlers.ts`: アイテムの起動・フォルダー表示
- `iconHandlers.ts`: ファビコン取得・アイコン抽出
- `windowHandlers.ts`: ウィンドウ固定化制御

## 主要IPCチャンネル
- `get-config-folder`: ユーザーデータディレクトリパスを返す
- `load-data-files`: 全てのdata*.txtファイルを読み込み、パース
- `save-temp-data`: 一時アイテムを保存
- `open-item`: ファイル/URL/アプリを起動
- `open-parent-folder`: エクスプローラーでアイテムを表示
- `fetch-favicon`: ウェブサイトのファビコンをダウンロード
- `extract-icon`: アプリケーションアイコンを抽出
- `extract-custom-uri-icon`: カスタムURIスキーマのハンドラーアプリアイコンを抽出
- `extract-file-icon-by-extension`: ファイル拡張子ベースのアイコン抽出
- `load-cached-icons`: キャッシュされたアイコンを一括読み込み
- `get-window-pin-state`: ウィンドウ固定状態を取得
- `set-window-pin-state`: ウィンドウ固定状態を設定
- `register-items`: アイテムをデータファイルに登録
- `is-directory`: パスがディレクトリかどうかを判定
- `sort-data-files`: データファイルをパスの昇順でソート
- `load-raw-data-files`: 生データファイルを展開せずに読み込み（編集モード用）
- `save-raw-data-files`: 生データファイルを直接保存（編集モード用）
- `set-edit-mode`: 編集モードの状態を設定（ウィンドウサイズとフォーカス制御用）
- `get-edit-mode`: 編集モードの状態を取得
- `update-item`: 個別アイテムの更新（エディットハンドラー - 実装は削除済み）
- `delete-items`: 複数アイテムの削除（エディットハンドラー - 実装は削除済み）
- `batch-update-items`: 複数アイテムの一括更新（エディットハンドラー - 実装は削除済み）
- `getPathForFile`: **プリロードAPI** ドラッグ&ドロップされたファイルのパスを取得
- `quit-app`: アプリケーションを終了

## データフロー

### 通常モード（表示・起動）
1. メインプロセスが`%APPDATA%/quickdashlauncher/config/`からデータファイルを読み込む
2. データファイル処理時に特殊な形式を自動変換
   - `dir,`ディレクティブ: 指定ディレクトリをスキャンしてファイル・フォルダを展開
     - デフォルト動作: 全てのファイルとフォルダをインポート（深さ0）
     - オプション指定可能: `depth`, `types`, `filter`, `exclude`, `prefix`
     - プレフィックス指定時は展開されるアイテム名に自動付与
   - 特定拡張子ファイル: .lnkファイルなどは自動的にターゲット情報を解析
3. パーサーが複数のデータファイルをマージし、重複を削除し、名前順でソート
4. レンダラーがリアルタイムフィルタリングでアイテムを表示
5. ユーザーアクションがシステム操作のためのIPCコールをメインプロセスにトリガー

### 編集モード（生データ編集）
1. 編集モード開始時にウィンドウサイズを自動拡大（1000x700px）
2. 編集モード中はフォーカスアウトでもウィンドウが非表示にならない
3. `load-raw-data-files`でデータファイルを展開せずに読み込み
4. `RawDataLine`型として行ごとにパース（種類：directive, item, comment, empty）
5. `EditableRawItemList`コンポーネントでテーブル形式表示
   - テーブル構成：`☑️ | # | 種類 | 名前 | パスと引数 | 操作`
   - 通常アイテム：名前列で表示名を個別編集可能、パスと引数列でパス＋引数を編集可能
   - DIRディレクティブ：名前列は編集不可（ハイフン表示）、パスと引数列でフォルダパス＋オプションを編集可能
6. ヘッダーに編集中のファイル名を表示
7. ユーザーが行の追加・削除・編集を実行
8. `save-raw-data-files`で変更内容をファイルに直接書き込み
9. 行番号の再採番とファイルバックアップを自動実行
10. 編集モード終了時にウィンドウサイズを元のサイズ（479x506px）に復元

## データ処理システム

### 設計原則
- **一元化された処理**: 同種のデータは共通の処理関数で統一的に処理
- **拡張可能性**: 新しいファイル形式やデータソースを容易に追加可能
- **エラー処理**: 個別のアイテム処理エラーがシステム全体に影響しない設計

### 処理パターン
1. **ディレクトリベース**: `dir,パス`形式でディレクトリ内容を動的に取得
2. **ファイル変換**: 特定の拡張子ファイルを実行可能な形式に自動変換
3. **直接指定**: 明示的に指定されたパスをそのまま使用

### データ変換の仕組み
- **入力**: 多様な形式（ディレクトリパス、ショートカットファイル、実行ファイル等）
- **処理**: ファイル種別に応じた適切な解析・変換処理
- **出力**: 統一されたCSV形式（`名前,パス,引数,メタデータ`）

## ウィンドウ制御システム

### ウィンドウ固定化機能
- **実装場所**: `src/main/windowManager.ts`
- **状態管理**: メインプロセスで`isPinned`フラグを管理
- **制御ロジック**: 固定中はウィンドウのblurイベントで非表示にならない
- **UI制御**: レンダラーで固定ボタン（📌）の状態を管理

### ウィンドウ表示制御
- **グローバルホットキー**: `Ctrl+Alt+W`でウィンドウ表示/非表示
- **フォーカスアウト**: 固定されていない場合、フォーカスを失うと自動的に非表示
- **編集モード時のフォーカス制御**: 編集モード中はフォーカスアウトでもウィンドウが非表示にならない
- **Escapeキー**: 固定状態に関係なく、Escapeキーで非表示可能
- **システムトレイ**: ダブルクリックでウィンドウ表示

### IPC通信フロー
1. レンダラーが固定ボタンクリック → `set-window-pin-state`
2. メインプロセスが固定状態を更新 → `windowManager.setWindowPinState()`
3. レンダラーが固定状態を取得 → `get-window-pin-state`
4. blur イベントで固定状態と編集モード状態をチェック → 非固定かつ非編集モード時のみ非表示

### 編集モードのウィンドウ制御
- **ウィンドウサイズ管理**: 通常モードのサイズを保存し、編集モード時に拡大
- **フォーカス制御**: 編集モード中は`isEditMode`フラグでフォーカスアウトを無効化
- **サイズ復元**: 編集モード終了時に保存した元のサイズに自動復元

### 編集モードのIPC通信フロー
1. レンダラーが編集モード切り替え → `set-edit-mode`
2. メインプロセスが編集モード状態を更新 → `windowManager.setEditMode()`
3. ウィンドウサイズとフォーカス制御を自動調整
4. レンダラーが編集モード状態を取得 → `get-edit-mode`