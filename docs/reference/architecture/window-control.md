# ウィンドウ制御システム

## ウィンドウ固定化機能

- **実装場所**: `src/main/windowManager.ts`
- **状態管理**: メインプロセスで`isPinned`フラグを管理
- **制御ロジック**: 固定中はウィンドウのblurイベントで非表示にならない
- **UI制御**: レンダラーで固定ボタン（📌）の状態を管理

## ウィンドウ表示制御

- **グローバルホットキー**: 設定したホットキー（デフォルト: `Alt+Space`）でウィンドウ表示/非表示
- **フォーカスアウト**: 固定されていない場合、フォーカスを失うと自動的に非表示
- **編集モード時のフォーカス制御**: 編集モード中はフォーカスアウトでもウィンドウが非表示にならない
- **Escapeキー**: 固定状態に関係なく、Escapeキーで非表示可能
- **システムトレイ**: ダブルクリックでウィンドウ表示、右クリックでメニュー表示

### ウィンドウ表示位置制御

ホットキーでウィンドウを表示する際、設定に応じて表示位置を制御します。

#### 表示位置モード

ウィンドウの表示位置は`windowPositionMode`設定によって以下の3つのモードから選択できます：

**1. 画面中央モード (`center`)**
- ウィンドウを常に画面中央に配置します
- デフォルトモードです
- 実装: `mainWindow.center()`を呼び出し

**2. マウスカーソル位置モード (`cursor`)**
- ウィンドウをマウスカーソルの位置を中心に配置します
- カーソル位置がウィンドウの中心になるように計算されます
- 画面外にはみ出さないように自動的に位置調整が行われます
- マルチモニター環境では、カーソルがあるモニターの作業領域（タスクバーを除く領域）内に配置されます
- 実装: `screen.getCursorScreenPoint()`でカーソル位置を取得し、ウィンドウサイズとディスプレイの作業領域を考慮して位置を計算

**3. 固定位置モード (`fixed`)**
- ユーザーが手動で移動した位置を記憶して、次回も同じ位置に表示します
- 初回表示時（`windowPositionX=0, windowPositionY=0`の場合）は画面中央に配置され、その位置が自動保存されます
- ウィンドウの`moved`イベントを監視し、ユーザーがウィンドウを移動すると自動的に位置を保存します
- 保存された座標（`windowPositionX`, `windowPositionY`）は`settings.json`に永続化されます

#### 実装詳細

**関数: `setWindowPosition(mode?: WindowPositionMode)`**
- 指定されたモードに応じてウィンドウを適切な位置に配置します
- `mode`が省略された場合は、設定ファイルから`windowPositionMode`を読み込みます
- 実装場所: `src/main/windowManager.ts`

**関数: `saveWindowPosition()`**
- `fixed`モードの場合のみ、現在のウィンドウ位置を設定ファイルに保存します
- ウィンドウの`moved`イベントハンドラーから自動的に呼び出されます
- 実装場所: `src/main/windowManager.ts`

**関数: `showMainWindow()`**
- ホットキー押下時にウィンドウを表示する際に使用されます
- 内部で`setWindowPosition()`を呼び出して位置を設定してから表示します
- 実装場所: `src/main/windowManager.ts`

**関数: `showWindowAtCenter()`**
- タスクトレイメニューの「画面中央に表示」から呼び出されます
- 設定に関係なく、強制的に画面中央に表示します
- 実装場所: `src/main/windowManager.ts`

#### ウィンドウ位置の自動保存

`fixed`モード時のみ、以下のタイミングでウィンドウ位置が自動保存されます：

1. **ウィンドウ移動時**: ユーザーがウィンドウをドラッグして移動したとき（`moved`イベント）
2. **初回表示時**: `windowPositionX=0, windowPositionY=0`の場合、画面中央に配置後に位置を保存

### システムトレイメニュー

システムトレイアイコンを右クリックすると、以下のメニューが表示されます：

1. **バージョン情報**: `QuickDashLauncher v0.2.8` - 現在のバージョンを表示（選択不可）
2. **表示**: メインウィンドウを表示（設定されているホットキーも表示）
3. **設定...**: 管理ウィンドウの設定タブを開く（`showAdminWindowWithTab('settings')`を呼び出し）
4. **データフォルダを開く**: 設定・データフォルダをエクスプローラーで開く（`shell.openPath`使用）
5. **ヘルプ**: GitHubリポジトリをブラウザで開く（`shell.openExternal`使用）
6. **終了**: アプリケーションを終了（`app.quit()`）

詳細は [システムトレイメニュー](../../manual/system-tray.md) を参照してください。

## IPC通信フロー

1. レンダラーが固定ボタンクリック → `set-window-pin-state`
2. メインプロセスが固定状態を更新 → `windowManager.setWindowPinState()`
3. レンダラーが固定状態を取得 → `get-window-pin-state`
4. blur イベントで固定状態と編集モード状態をチェック → 非固定かつ非編集モード時のみ非表示

## 編集モードのウィンドウ制御

- **ウィンドウサイズ管理**: 通常モードのサイズを保存し、編集モード時に拡大
- **フォーカス制御**: 編集モード中は`isEditMode`フラグでフォーカスアウトを無効化
- **サイズ復元**: 編集モード終了時に保存した元のサイズに自動復元

### 編集モードのIPC通信フロー

1. レンダラーが編集モード切り替え → `set-edit-mode`
2. メインプロセスが編集モード状態を更新 → `windowManager.setEditMode()`
3. ウィンドウサイズとフォーカス制御を自動調整
4. レンダラーが編集モード状態を取得 → `get-edit-mode`

## 管理ウィンドウ制御

### 実装場所
- **メインプロセス**: `src/main/adminWindowManager.ts`
- **レンダラー**: `src/renderer/AdminApp.tsx`

### タブ指定での表示機能

1. **メニューからのタブ指定**
   - 「基本設定」メニュー → `openEditWindowWithTab('settings')`
   - 「アイテム管理」メニュー → `openEditWindowWithTab('edit')`

2. **タブ変更の通信フロー**
   - メインプロセスから`set-active-tab`イベントを送信
   - AdminAppがイベントを受信してタブを切り替え

3. **初期タブのリセット**
   - ウィンドウが非表示になるたびに初期タブをリセット
   - 次回開く際は指定されたタブが正しく表示される

### 管理ウィンドウのIPC通信

- `show-edit-window`: 管理ウィンドウを表示
- `hide-edit-window`: 管理ウィンドウを非表示
- `toggle-edit-window`: 表示/非表示を切り替え
- `open-edit-window-with-tab`: 指定タブで開く
- `get-initial-tab`: 初期タブを取得
- `set-active-tab`: アクティブタブを変更（イベント）

## 関連ドキュメント

- [アーキテクチャ概要](overview.md) - システム全体の構造
- [IPCチャンネル詳細](ipc-channels.md) - ウィンドウ制御関連のIPCチャンネル
- [アプリケーション設定](../manual/app-settings.md) - 設定画面へのアクセス方法