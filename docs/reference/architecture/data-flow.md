# データフロー

QuickDashLauncherのデータ処理フローを説明します。

## 初回起動フロー

1. アプリケーション起動時（`main.ts`）でホットキー設定の有無をチェック
   - `hotkey`が空の場合: 初回起動と判定し、`isFirstLaunch = true`を設定
   - `hotkey`に値がある場合: 通常起動
2. レンダラープロセスで`settings:is-first-launch` IPCを呼び出して初回起動かチェック
   - 初回起動の場合: 初回設定画面（`FirstLaunchSetup`）を表示
   - 通常起動の場合: メインウィンドウを表示
3. 初回設定画面でユーザーがホットキーを設定
4. 設定完了時:
   - `settings:set-multiple` IPCでホットキーを含む設定を保存
   - ホットキーが設定されると自動的に初回起動モードが解除される
   - `settings:change-hotkey` IPCでホットキーをグローバル登録
5. 初回設定画面を非表示、メインウィンドウに遷移

## 通常モード（表示・起動）

1. メインプロセスが`%APPDATA%/quickdashlauncher/config/`からデータファイルを読み込む
2. データファイル処理時に特殊な形式を自動変換
   - `dir,`フォルダ取込アイテム: 指定ディレクトリをスキャンしてファイル・フォルダを展開
     - デフォルト動作: 全てのファイルとフォルダをインポート（深さ0）
     - オプション指定可能: `depth`, `types`, `filter`, `exclude`, `prefix`
     - プレフィックス指定時は展開されるアイテム名に自動付与
   - 特定拡張子ファイル: .lnkファイルなどは自動的にターゲット情報を解析
3. パーサーが複数のデータファイルをマージし、重複を削除し、名前順でソート
4. レンダラーがリアルタイムフィルタリングでアイテムを表示
5. 検索クエリは履歴として`%APPDATA%/quickdashlauncher/config/history.csv`に保存（最大100件、重複は最新時刻で更新）
6. ユーザーアクションがシステム操作のためのIPCコールをメインプロセスにトリガー

## 編集モード（生データ編集）

1. 編集モード開始時にウィンドウサイズを自動拡大（1000x700px）
2. 編集モード中はフォーカスアウトでもウィンドウが非表示にならない
3. `load-raw-data-files`でデータファイルを展開せずに読み込み
4. `RawDataLine`型として行ごとにパース（種類：directive, item, comment, empty）
5. `EditableRawItemList`コンポーネントでテーブル形式表示
   - テーブル構成：`☑️ | # | 種類 | 名前 | パスと引数 | 操作`
   - 単一アイテム：名前列で表示名を個別編集可能、パスと引数列でパス＋引数を編集可能
   - フォルダ取込アイテム：名前列は編集不可（ハイフン表示）、パスと引数列でフォルダパス＋オプションを編集可能
6. ヘッダーに編集中のファイル名を表示
7. ユーザーが行の追加・削除・編集を実行
8. `save-raw-data-files`で変更内容をファイルに直接書き込み
9. 行番号の再採番とファイルバックアップを自動実行
10. 編集モード終了時にウィンドウサイズを元のサイズ（479x506px）に復元

## アイコン取得と進捗表示フロー

### ファビコン取得フロー
1. ユーザーが🌐ファビコン取得ボタンをクリック
2. `App.tsx`でURL型アイテムのフィルタリング（`item.type === 'url' && !item.icon`）
3. フィルタリングされたURLリストを`fetchFaviconsWithProgress`IPCに送信
4. メインプロセスで逐次処理開始、進捗イベント送信開始
   - `icon-progress-start`: 処理開始通知（処理種別、総数）
   - `icon-progress-update`: 各アイテム処理前後の進捗更新通知
   - `icon-progress-complete`: 処理完了通知（最終結果、エラー数）
5. レンダラープロセスで`useIconProgress`フックが進捗イベントを受信
6. `IconProgressBar`コンポーネントがリアルタイム進捗表示
7. 取得結果をレンダラーに返却、`mainItems`と`tempItems`を更新
8. 完了後3秒で進捗バーが自動非表示

### アイコン抽出フロー
1. ユーザーが🎨全アイコンを抽出ボタンをクリック
2. `App.tsx`で非URL型アイテムのフィルタリング（`!item.icon && item.type !== 'url'`）
3. フィルタリングされたアイテムリストを`extractIconsWithProgress`IPCに送信
4. メインプロセスで逐次処理開始、進捗イベント送信
   - app型: ショートカット（.lnk）または実行ファイル（.exe）からアイコン抽出
   - customUri型: レジストリからスキーマハンドラーアプリを特定しアイコン抽出
   - file型: 拡張子ベースでシステム関連付けアイコンを抽出
5. レンダラープロセスで進捗表示（ファビコン取得と同様のフロー）
6. 抽出結果をレンダラーに返却、アイテムリストを更新

### 進捗データ構造
```typescript
IconProgress {
  type: 'favicon' | 'icon',        // 処理種別
  current: number,                 // 現在完了数
  total: number,                   // 総数
  currentItem: string,             // 処理中アイテム（URL/パス）
  errors: number,                  // エラー数
  startTime: number,               // 開始時刻
  isComplete: boolean              // 完了フラグ
}
```

### 進捗表示UI仕様
- **表示位置**: メインウィンドウ下部（ItemListの下）
- **表示内容**: プログレスバー、進捗数値、経過時間、推定残り時間、エラー数
- **非表示条件**: 処理完了後3秒で自動非表示
- **操作性**: 非モーダル設計により、進捗表示中も他の操作が継続可能

## コマンドヒストリー機能

### 履歴管理フロー
1. ユーザーが検索ボックスに入力して実行（Enter等）
2. 検索クエリを`%APPDATA%/quickdashlauncher/config/history.csv`に保存
   - CSV形式: `検索クエリ,実行時刻（ISO8601形式）`
   - 重複クエリは削除され、最新の実行時刻で更新
   - 最大100件を保持（古いものから自動削除）
3. Ctrl+↑/↓キーで履歴ナビゲート
   - 現在の検索ボックス内容を一時保存
   - 履歴を時系列順（新しいものから古いもの）で表示
   - Escapeキーまたは新規入力で履歴ナビゲートを終了

### データ構造
```typescript
HistoryEntry {
  query: string,      // 検索クエリ
  timestamp: string   // 実行時刻（ISO8601形式）
}
```

## 関連ドキュメント

- [アーキテクチャ概要](overview.md) - システム全体の構造
- [IPCチャンネル詳細](ipc-channels.md) - 各IPCチャンネルの仕様
- [アイテム管理](../manual/item-management.md) - 編集モードの詳細仕様
- [アイコンシステム](../manual/icon-system.md) - アイコン取得・管理システム